/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/MyWebGL/MathLib/MathLib.ts":
/*!****************************************!*\
  !*** ./src/MyWebGL/MathLib/MathLib.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MathLib = /** @class */ (function () {\n    function MathLib() {\n    }\n    MathLib.radiansToDegree = function (radians) {\n        return radians * (180.0 / Math.PI);\n    };\n    MathLib.degreeToRadians = function (degree) {\n        return degree * (Math.PI / 180.0);\n    };\n    MathLib.sineTheorem = function (source, degreeSource, degreeTarget) {\n        return source / Math.sin(MathLib.degreeToRadians(degreeSource)) *\n            Math.sin(MathLib.degreeToRadians(degreeTarget));\n    };\n    return MathLib;\n}());\nexports.MathLib = MathLib;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/MathLib/MathLib.ts?");

/***/ }),

/***/ "./src/MyWebGL/MathLib/Matric.ts":
/*!***************************************!*\
  !*** ./src/MyWebGL/MathLib/Matric.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Vector_1 = __webpack_require__(/*! ./Vector */ \"./src/MyWebGL/MathLib/Vector.ts\");\nvar Matric = /** @class */ (function (_super) {\n    __extends(Matric, _super);\n    function Matric(value) {\n        var _this = _super.call(this, value instanceof Array ? value.length : value) || this;\n        for (var i = 0; i < _this.length; i++) {\n            _this[i] = value instanceof Array ? new Vector_1.Vector(value[i]) : new Vector_1.Vector(value);\n        }\n        Object.setPrototypeOf(_this, Matric.prototype);\n        return _this;\n    }\n    Matric.prototype.setValues = function (values) {\n        if (values.length != this.length) {\n            throw new Error('Length of values is different with length of matric.');\n        }\n        for (var i = 0; i < this.length; i++) {\n            this[i] = new Vector_1.Vector(values[i]);\n        }\n    };\n    Matric.prototype.transpose = function () {\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            var v = [];\n            for (var j = 0; j < this.length; j++) {\n                v.push(this[j][i]);\n            }\n            result.push(v);\n        }\n        return new Matric(result);\n    };\n    Matric.prototype.flatten = function () {\n        var t = this.transpose();\n        var result = [];\n        for (var i = 0; i < t.length; i++) {\n            for (var j = 0; j < t.length; j++) {\n                result.push(t[i][j]);\n            }\n        }\n        return new Float32Array(result);\n    };\n    return Matric;\n}(Array));\nexports.Matric = Matric;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/MathLib/Matric.ts?");

/***/ }),

/***/ "./src/MyWebGL/MathLib/Vector.ts":
/*!***************************************!*\
  !*** ./src/MyWebGL/MathLib/Vector.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Vector = /** @class */ (function (_super) {\n    __extends(Vector, _super);\n    function Vector(value) {\n        var _this = _super.call(this, value instanceof Array ? value.length : value) || this;\n        for (var i = 0; i < _this.length; i++) {\n            _this[i] = value instanceof Array ? value[i] : 0.0;\n        }\n        Object.setPrototypeOf(_this, Vector.prototype);\n        return _this;\n    }\n    Vector.prototype.setValues = function (values) {\n        if (values.length !== this.length) {\n            throw new Error('Length of values is different with length of vector.');\n        }\n        for (var i = 0; i < values.length; i++) {\n            this[i] = values[i];\n        }\n    };\n    Vector.prototype.getValues = function () {\n        var result = [];\n        this.forEach(function (val) {\n            result.push(val);\n        });\n        return result;\n    };\n    Vector.prototype.equal = function (v) {\n        if (this.length !== v.length) {\n            return false;\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] !== v[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Vector.prototype.substract = function (v) {\n        if (this.length !== v.length) {\n            throw new Error('Length of two vectors is different.');\n        }\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            result.push(this[i] - v[i]);\n        }\n        return new Vector(result);\n    };\n    Vector.prototype.dot = function (v) {\n        if (this.length !== v.length) {\n            throw new Error('Length of two vectors is different.');\n        }\n        var sum = 0.0;\n        for (var i = 0; i < this.length; i++) {\n            sum += this[i] * v[i];\n        }\n        return sum;\n    };\n    Vector.prototype.len = function () {\n        return Math.sqrt(this.dot(this));\n    };\n    Vector.prototype.normalizeExceptLast = function () {\n        var vals = this.getValues();\n        vals.pop();\n        var v = new Vector(vals);\n        var result = v.normalize().getValues();\n        result.push(this[this.length - 1]);\n        return new Vector(result);\n    };\n    Vector.prototype.normalize = function (exceptLast) {\n        if (exceptLast === void 0) { exceptLast = false; }\n        if (exceptLast) {\n            return this.normalizeExceptLast();\n        }\n        var len = this.len();\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            result.push(this[i] / len);\n        }\n        return new Vector(result);\n    };\n    Vector.prototype.cross = function (v) {\n        if (this.length !== v.length) {\n            throw new Error('Length of two vectors is different.');\n        }\n        var result = [\n            this[1] * v[2] - this[2] * v[1],\n            this[2] * v[0] - this[0] * v[2],\n            this[0] * v[1] - this[1] * v[0]\n        ];\n        return new Vector(result);\n    };\n    Vector.prototype.negate = function () {\n        for (var i = 0; i < this.length; i++) {\n            this[i] = -this[i];\n        }\n    };\n    Vector.prototype.flatten = function () {\n        return new Float32Array(this.getValues());\n    };\n    Vector.prototype.mix = function (v, n) {\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            result.push((1 - n) * this[i] + n * v[i]);\n        }\n        return new Vector(result);\n    };\n    Vector.prototype.mult = function (v) {\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            result.push(this[i] * v[i]);\n        }\n        return new Vector(result);\n    };\n    return Vector;\n}(Array));\nexports.Vector = Vector;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/MathLib/Vector.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/MyWebGL.ts":
/*!*************************************!*\
  !*** ./src/MyWebGL/core/MyWebGL.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GlslUniform_1 = __webpack_require__(/*! ./glsl/parameter/GlslUniform */ \"./src/MyWebGL/core/glsl/parameter/GlslUniform.ts\");\nvar MyWebGL = /** @class */ (function () {\n    function MyWebGL(canvasId, contextId) {\n        this.canvas = document.getElementById(canvasId);\n        this.gl = this.canvas.getContext('webgl');\n        this.clearCanvas();\n    }\n    MyWebGL.prototype.clearCanvas = function () {\n        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n        this.gl.clearColor(1, 1, 1, 1);\n    };\n    MyWebGL.prototype.clear = function () {\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n    };\n    Object.defineProperty(MyWebGL.prototype, \"constant\", {\n        get: function () {\n            return this.gl;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MyWebGL.prototype, \"canvasWidth\", {\n        get: function () {\n            return this.canvas.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MyWebGL.prototype, \"canvasHeight\", {\n        get: function () {\n            return this.canvas.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MyWebGL.prototype.createShader = function (type, source) {\n        var shader = this.gl.createShader(type);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        return shader;\n    };\n    MyWebGL.prototype.useProgram = function (vsSource, fsSource) {\n        var vShader = this.createShader(this.gl.VERTEX_SHADER, vsSource);\n        var fShader = this.createShader(this.gl.FRAGMENT_SHADER, fsSource);\n        this.program = this.gl.createProgram();\n        this.gl.attachShader(this.program, vShader);\n        this.gl.attachShader(this.program, fShader);\n        this.gl.linkProgram(this.program);\n        this.gl.useProgram(this.program);\n    };\n    MyWebGL.prototype.useAttribute = function (attribute) {\n        var buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(attribute.buffer), this.gl.STATIC_DRAW);\n        var attributeLocation = this.gl.getAttribLocation(this.program, attribute.name);\n        this.gl.enableVertexAttribArray(attributeLocation);\n        this.gl.vertexAttribPointer(attributeLocation, attribute.size, this.gl.FLOAT, false, 0, 0);\n    };\n    MyWebGL.prototype.useUniform = function (uniform) {\n        var uniformLocation = this.gl.getUniformLocation(this.program, uniform.name);\n        if (uniform.type === GlslUniform_1.GlslUniformType.mat4) {\n            this.gl.uniformMatrix4fv(uniformLocation, false, uniform.value);\n        }\n        else if (uniform.type === GlslUniform_1.GlslUniformType.vec4) {\n            this.gl.uniform4fv(uniformLocation, uniform.value);\n        }\n        else if (uniform.type === GlslUniform_1.GlslUniformType.mat3) {\n            this.gl.uniformMatrix3fv(uniformLocation, false, uniform.value);\n        }\n        else if (uniform.type === GlslUniform_1.GlslUniformType.vec3) {\n            this.gl.uniform3fv(uniformLocation, uniform.value);\n        }\n        else if (uniform.type === GlslUniform_1.GlslUniformType.float) {\n            this.gl.uniform1f(uniformLocation, uniform.value);\n        }\n    };\n    MyWebGL.prototype.useAttributes = function (attributes) {\n        var _this = this;\n        attributes.forEach(function (value, key) {\n            _this.useAttribute(value);\n        });\n    };\n    MyWebGL.prototype.useUniforms = function (uniforms) {\n        var _this = this;\n        uniforms.forEach(function (value, key) {\n            _this.useUniform(value);\n        });\n    };\n    MyWebGL.prototype.setUniform = function (uniform, val) {\n        var uniformLocation = this.gl.getUniformLocation(this.program, uniform);\n        this.gl.uniform3fv(uniformLocation, val);\n    };\n    MyWebGL.prototype.createElementBuffer = function (data) {\n        var buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this.gl.STATIC_DRAW);\n    };\n    MyWebGL.prototype.drawArrays = function (mode, count) {\n        this.gl.drawArrays(mode, 0, count);\n    };\n    MyWebGL.prototype.drawElements = function (mode, count, type) {\n        this.gl.drawElements(mode, count, type, 0);\n    };\n    MyWebGL.prototype.enable = function (cap) {\n        this.gl.enable(cap);\n    };\n    MyWebGL.prototype.render = function (renderObj) {\n        if (renderObj.isFirstRender()) {\n            this.useProgram(renderObj.vsSource, renderObj.fsSource);\n            this.useAttributes(renderObj.attributes);\n        }\n        if (renderObj.hasUniform()) {\n            this.useUniforms(renderObj.uniforms);\n        }\n        if (renderObj.isDrawElement()) {\n            this.createElementBuffer(renderObj.indices);\n            this.drawElements(renderObj.mode, renderObj.count, renderObj.type);\n        }\n        else {\n            this.drawArrays(renderObj.mode, renderObj.count);\n        }\n    };\n    return MyWebGL;\n}());\nexports.MyWebGL = MyWebGL;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/MyWebGL.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/RenderObject.ts":
/*!******************************************!*\
  !*** ./src/MyWebGL/core/RenderObject.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar RenderObject = /** @class */ (function () {\n    function RenderObject(vsSource, fsSource, mode, count, attributes, uniforms) {\n        this.type = null;\n        this.indices = null;\n        this.firstRender = true;\n        this.vsSource = vsSource;\n        this.fsSource = fsSource;\n        this.mode = mode;\n        this.count = count;\n        this.attributes = attributes;\n        this.uniforms = uniforms;\n    }\n    RenderObject.prototype.hasUniform = function () {\n        return this.uniforms.size > 0;\n    };\n    RenderObject.prototype.updateUniform = function (name, val) {\n        this.uniforms.get(name).update(val);\n    };\n    RenderObject.prototype.drawElement = function (type, indices) {\n        this.type = type;\n        this.indices = indices;\n    };\n    RenderObject.prototype.isDrawElement = function () {\n        return !(this.indices === null);\n    };\n    RenderObject.prototype.isFirstRender = function () {\n        if (this.firstRender === true) {\n            this.firstRender = false;\n            return true;\n        }\n        return false;\n    };\n    return RenderObject;\n}());\nexports.RenderObject = RenderObject;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/RenderObject.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts":
/*!**********************************************************!*\
  !*** ./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GlslAttribute = /** @class */ (function () {\n    function GlslAttribute(name, size, buffer) {\n        this.name = name;\n        this.size = size;\n        this.buffer = buffer;\n    }\n    return GlslAttribute;\n}());\nexports.GlslAttribute = GlslAttribute;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/glsl/parameter/GlslUniform.ts":
/*!********************************************************!*\
  !*** ./src/MyWebGL/core/glsl/parameter/GlslUniform.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GlslUniformType;\n(function (GlslUniformType) {\n    GlslUniformType[GlslUniformType[\"mat4\"] = 0] = \"mat4\";\n    GlslUniformType[GlslUniformType[\"vec4\"] = 1] = \"vec4\";\n    GlslUniformType[GlslUniformType[\"mat3\"] = 2] = \"mat3\";\n    GlslUniformType[GlslUniformType[\"vec3\"] = 3] = \"vec3\";\n    GlslUniformType[GlslUniformType[\"float\"] = 4] = \"float\";\n})(GlslUniformType || (GlslUniformType = {}));\nexports.GlslUniformType = GlslUniformType;\nvar GlslUniform = /** @class */ (function () {\n    function GlslUniform(name, type) {\n        this.name = name;\n        this.type = type;\n    }\n    GlslUniform.prototype.update = function (value) {\n        this.value = value;\n    };\n    return GlslUniform;\n}());\nexports.GlslUniform = GlslUniform;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/glsl/parameter/GlslUniform.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/transform/ModelView.ts":
/*!*************************************************!*\
  !*** ./src/MyWebGL/core/transform/ModelView.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Matric_1 = __webpack_require__(/*! ../../MathLib/Matric */ \"./src/MyWebGL/MathLib/Matric.ts\");\nvar ModelView = /** @class */ (function () {\n    function ModelView() {\n    }\n    ModelView.lookAt = function (eye, at, up) {\n        if (eye.equal(at)) {\n            return new Matric_1.Matric([\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1, 0],\n                [0, 0, 0, 1]\n            ]);\n        }\n        var v = at.substract(eye).normalize();\n        var n = v.cross(up).normalize();\n        var u = n.cross(v).normalize();\n        v.negate();\n        var n_val = n.getValues();\n        var u_val = u.getValues();\n        var v_val = v.getValues();\n        n_val.push(-n.dot(eye));\n        u_val.push(-u.dot(eye));\n        v_val.push(-v.dot(eye));\n        return new Matric_1.Matric([\n            n_val,\n            u_val,\n            v_val,\n            [0, 0, 0, 1]\n        ]);\n    };\n    return ModelView;\n}());\nexports.ModelView = ModelView;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/transform/ModelView.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/transform/Projection.ts":
/*!**************************************************!*\
  !*** ./src/MyWebGL/core/transform/Projection.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Matric_1 = __webpack_require__(/*! ../../MathLib/Matric */ \"./src/MyWebGL/MathLib/Matric.ts\");\nvar MathLib_1 = __webpack_require__(/*! ../../MathLib/MathLib */ \"./src/MyWebGL/MathLib/MathLib.ts\");\nvar Projection = /** @class */ (function () {\n    function Projection() {\n    }\n    Projection.ortho = function (left, right, bottom, top, near, far) {\n        var w = right - left;\n        var h = top - bottom;\n        var d = far - near;\n        var result = new Matric_1.Matric([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ]);\n        result[0][0] = 2.0 / w;\n        result[1][1] = 2.0 / h;\n        result[2][2] = -2.0 / d;\n        result[0][3] = -(left + right) / w;\n        result[1][3] = -(top + bottom) / h;\n        result[2][3] = -(near + far) / d;\n        return result;\n    };\n    Projection.perspective = function (fovy, aspect, near, far) {\n        var f = 1.0 / Math.tan(MathLib_1.MathLib.degreeToRadians(fovy) / 2);\n        var d = far - near;\n        var result = new Matric_1.Matric([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ]);\n        result[0][0] = f / aspect;\n        result[1][1] = f;\n        result[2][2] = -(near + far) / d;\n        result[2][3] = -2 * near * far / d;\n        result[3][2] = -1;\n        result[3][3] = 0.0;\n        return result;\n    };\n    return Projection;\n}());\nexports.Projection = Projection;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/transform/Projection.ts?");

/***/ }),

/***/ "./src/MyWebGL/core/transform/Transform.ts":
/*!*************************************************!*\
  !*** ./src/MyWebGL/core/transform/Transform.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Matric_1 = __webpack_require__(/*! ../../MathLib/Matric */ \"./src/MyWebGL/MathLib/Matric.ts\");\nvar MathLib_1 = __webpack_require__(/*! ../../MathLib/MathLib */ \"./src/MyWebGL/MathLib/MathLib.ts\");\nvar Transform = /** @class */ (function () {\n    function Transform() {\n    }\n    Transform.rotateX = function (degree) {\n        var c = Math.cos(MathLib_1.MathLib.degreeToRadians(degree));\n        var s = Math.sin(MathLib_1.MathLib.degreeToRadians(degree));\n        return new Matric_1.Matric([\n            [1.0, 0.0, 0.0, 0.0],\n            [0.0, c, -s, 0.0],\n            [0.0, s, c, 0.0],\n            [0.0, 0.0, 0.0, 1.0]\n        ]);\n    };\n    Transform.rotateY = function (degree) {\n        var c = Math.cos(MathLib_1.MathLib.degreeToRadians(degree));\n        var s = Math.sin(MathLib_1.MathLib.degreeToRadians(degree));\n        return new Matric_1.Matric([\n            [c, 0.0, s, 0.0],\n            [0.0, 1.0, 0.0, 0.0],\n            [-s, 0.0, c, 0.0],\n            [0.0, 0.0, 0.0, 1.0]\n        ]);\n    };\n    Transform.rotateZ = function (degree) {\n        var c = Math.cos(MathLib_1.MathLib.degreeToRadians(degree));\n        var s = Math.sin(MathLib_1.MathLib.degreeToRadians(degree));\n        return new Matric_1.Matric([\n            [c, -s, 0.0, 0.0],\n            [s, c, 0.0, 0.0],\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0]\n        ]);\n    };\n    Transform.translate = function (x, y, z) {\n        var result = new Matric_1.Matric([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ]);\n        result[0][3] = x;\n        result[1][3] = y;\n        result[2][3] = z;\n        return result;\n    };\n    Transform.shadow = function (y) {\n        var result = new Matric_1.Matric([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ]);\n        result[3][3] = 0;\n        result[3][1] = -1 / y;\n        return result;\n    };\n    return Transform;\n}());\nexports.Transform = Transform;\n\n\n//# sourceURL=webpack:///./src/MyWebGL/core/transform/Transform.ts?");

/***/ }),

/***/ "./src/color_cube.ts":
/*!***************************!*\
  !*** ./src/color_cube.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Transform_1 = __webpack_require__(/*! ./MyWebGL/core/transform/Transform */ \"./src/MyWebGL/core/transform/Transform.ts\");\nvar MyWebGL_1 = __webpack_require__(/*! ./MyWebGL/core/MyWebGL */ \"./src/MyWebGL/core/MyWebGL.ts\");\nvar GlslAttribute_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslAttribute */ \"./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts\");\nvar GlslUniform_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslUniform */ \"./src/MyWebGL/core/glsl/parameter/GlslUniform.ts\");\nvar RenderObject_1 = __webpack_require__(/*! ./MyWebGL/core/RenderObject */ \"./src/MyWebGL/core/RenderObject.ts\");\nvar vsSource = \"\\n    attribute vec4 vPosition;\\n    attribute vec4 vColor;\\n    \\n    varying vec4 fColor;\\n\\n    uniform mat4 rx;\\n    uniform mat4 ry;\\n    uniform mat4 rz;\\n\\n    void main() {\\n        fColor = vColor;\\n        gl_Position = rz * ry * rx * vPosition;\\n    }\\n\";\nvar fsSource = \"\\n    precision mediump float;\\n\\n    varying vec4 fColor;\\n\\n    void main() {\\n        gl_FragColor = fColor;\\n    }\\n\";\nvar axis = 0;\nvar theta = [0, 0, 0];\nvar positions = [];\nvar colors = [];\nvar myWebGL;\nvar renderObj;\n/*\n*            0----------1\n*            -        --\n*          3----------2-\n*           -        - -\n*           - 4      - -5\n*           -        --\n*          7----------6\n*/\nfunction getCubePositions() {\n    function getPositions(a, b, c, d) {\n        var vertexs = [\n            [-0.5, -0.5, 0.5],\n            [-0.5, 0.5, 0.5],\n            [0.5, 0.5, 0.5],\n            [0.5, -0.5, 0.5],\n            [-0.5, -0.5, -0.5],\n            [-0.5, 0.5, -0.5],\n            [0.5, 0.5, -0.5],\n            [0.5, -0.5, -0.5],\n        ];\n        var vertexColors = [\n            [0.0, 0.0, 0.0, 1.0],\n            [1.0, 0.0, 0.0, 1.0],\n            [1.0, 1.0, 0.0, 1.0],\n            [0.0, 1.0, 0.0, 1.0],\n            [0.0, 0.0, 1.0, 1.0],\n            [1.0, 0.0, 1.0, 1.0],\n            [0.0, 1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0, 1.0] // white\n        ];\n        var indices = [a, b, c, a, c, d];\n        for (var i = 0; i < indices.length; i++) {\n            positions = positions.concat(vertexs[indices[i]]);\n            colors = colors.concat(vertexColors[a]);\n        }\n    }\n    getPositions(1, 0, 3, 2);\n    getPositions(2, 3, 7, 6);\n    getPositions(3, 0, 4, 7);\n    getPositions(6, 5, 1, 2);\n    getPositions(4, 5, 6, 7);\n    getPositions(5, 4, 0, 1);\n}\nfunction getAttributes() {\n    getCubePositions();\n    var attributes = new Map();\n    attributes.set('vPosition', new GlslAttribute_1.GlslAttribute('vPosition', 3, positions));\n    attributes.set('vColor', new GlslAttribute_1.GlslAttribute('vColor', 4, colors));\n    return attributes;\n}\nfunction getUniforms() {\n    var uniforms = new Map();\n    uniforms.set('rx', new GlslUniform_1.GlslUniform('rx', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('ry', new GlslUniform_1.GlslUniform('ry', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('rz', new GlslUniform_1.GlslUniform('rz', GlslUniform_1.GlslUniformType.mat4));\n    return uniforms;\n}\nfunction _render() {\n    theta[axis] += 2;\n    var rx = Transform_1.Transform.rotateX(theta[0]);\n    var ry = Transform_1.Transform.rotateY(theta[1]);\n    var rz = Transform_1.Transform.rotateZ(theta[2]);\n    renderObj.updateUniform('rx', rx.flatten());\n    renderObj.updateUniform('ry', ry.flatten());\n    renderObj.updateUniform('rz', rz.flatten());\n    myWebGL.clear();\n    myWebGL.render(renderObj);\n    window.requestAnimationFrame(_render);\n}\nfunction _drawCube() {\n    var attributes = getAttributes();\n    var uniforms = getUniforms();\n    renderObj = new RenderObject_1.RenderObject(vsSource, fsSource, myWebGL.constant.TRIANGLES, 36, attributes, uniforms);\n    myWebGL.enable(myWebGL.constant.DEPTH_TEST);\n    _render();\n}\nfunction drawCube(glId) {\n    myWebGL = new MyWebGL_1.MyWebGL(glId, 'webgl');\n    _drawCube();\n}\nexports.drawCube = drawCube;\nwindow.requestAnimationFrame(_render);\ndocument.getElementById('x').onclick = function () {\n    axis = 0;\n};\ndocument.getElementById('y').onclick = function () {\n    axis = 1;\n};\ndocument.getElementById('z').onclick = function () {\n    axis = 2;\n};\n\n\n//# sourceURL=webpack:///./src/color_cube.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pentagram_1 = __webpack_require__(/*! ./pentagram */ \"./src/pentagram.ts\");\nvar color_cube_1 = __webpack_require__(/*! ./color_cube */ \"./src/color_cube.ts\");\nvar sphere_1 = __webpack_require__(/*! ./sphere */ \"./src/sphere.ts\");\nvar three_objects_1 = __webpack_require__(/*! ./three_objects */ \"./src/three_objects.ts\");\nfunction main() {\n    pentagram_1.drawPentagram('gl-pentagram');\n    color_cube_1.drawCube('gl-cube');\n    sphere_1.drawSphere('gl-sphere');\n    three_objects_1.drawThreeObjects('gl-three');\n}\nwindow.onload = main;\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/pentagram.ts":
/*!**************************!*\
  !*** ./src/pentagram.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MathLib_1 = __webpack_require__(/*! ./MyWebGL/MathLib/MathLib */ \"./src/MyWebGL/MathLib/MathLib.ts\");\nvar MyWebGL_1 = __webpack_require__(/*! ./MyWebGL/core/MyWebGL */ \"./src/MyWebGL/core/MyWebGL.ts\");\nvar GlslAttribute_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslAttribute */ \"./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts\");\nvar RenderObject_1 = __webpack_require__(/*! ./MyWebGL/core/RenderObject */ \"./src/MyWebGL/core/RenderObject.ts\");\nvar vsSource = \"\\n    attribute vec4 a_position;\\n\\n    void main() {\\n        gl_Position = a_position;\\n    }\\n\";\nvar fsSourcePentagram = \"\\n    precision mediump float;\\n\\n    void main() {\\n        gl_FragColor = vec4(0, 0, 0, 1);\\n    }\\n\";\nvar fsSourcePentagon = \"\\n    precision mediump float;\\n\\n    void main() {\\n        gl_FragColor = vec4(1, 1, 0, 1);\\n    }\\n\";\nvar RADIUS = 1;\nfunction getPloygonPositions(num, radius, startDegree, stepDegree) {\n    var positions = [];\n    for (var i = 0; i < num; i++) {\n        var degree = startDegree + i * stepDegree;\n        var x = radius * Math.cos(MathLib_1.MathLib.degreeToRadians(degree));\n        var y = radius * Math.sin(MathLib_1.MathLib.degreeToRadians(degree));\n        positions.push([x, y]);\n    }\n    return positions;\n}\nfunction getPentagramPositions() {\n    var stepDegree = 360 / 5;\n    var startDegree = stepDegree / 2;\n    var pointsPositions = getPloygonPositions(5, RADIUS, startDegree, stepDegree);\n    var positions = [];\n    for (var i = 0; i < 3; i++) {\n        positions.push(pointsPositions[i][0], pointsPositions[i][1]);\n        positions.push(pointsPositions[i + 2][0], pointsPositions[i + 2][1]);\n        if (i != 2) {\n            positions.push(pointsPositions[i][0], pointsPositions[i][1]);\n            positions.push(pointsPositions[i + 3][0], pointsPositions[i + 3][1]);\n        }\n    }\n    return positions;\n}\nfunction getPentagonPositions() {\n    var startDegree = 0;\n    var stepDegree = 360 / 5;\n    var pointsPositions = getPloygonPositions(5, MathLib_1.MathLib.sineTheorem(RADIUS, 126, 18), startDegree, stepDegree);\n    var positions = [];\n    for (var i = 0; i < 5; i++) {\n        positions.push(pointsPositions[i][0], pointsPositions[i][1]);\n        positions.push(pointsPositions[(i + 1) % 5][0], pointsPositions[(i + 1) % 5][1]);\n        positions.push(0, 0);\n    }\n    return positions;\n}\nfunction getUniforms() {\n    var uniforms = new Map();\n    return uniforms;\n}\nfunction _drawPentagram(myWebGL) {\n    var positions = getPentagramPositions();\n    var attributes = new Map();\n    attributes.set('a_position', new GlslAttribute_1.GlslAttribute('a_position', 2, positions));\n    var uniforms = getUniforms();\n    var rendeObj = new RenderObject_1.RenderObject(vsSource, fsSourcePentagram, myWebGL.constant.LINES, 10, attributes, uniforms);\n    myWebGL.render(rendeObj);\n}\nfunction _drawPentagon(myWebGL) {\n    myWebGL.useProgram(vsSource, fsSourcePentagon);\n    var positions = getPentagonPositions();\n    var attributes = new Map();\n    attributes.set('a_position', new GlslAttribute_1.GlslAttribute('a_position', 2, positions));\n    var uniforms = getUniforms();\n    var rendeObj = new RenderObject_1.RenderObject(vsSource, fsSourcePentagon, myWebGL.constant.TRIANGLES, 15, attributes, uniforms);\n    myWebGL.render(rendeObj);\n}\nfunction drawPentagram(glId) {\n    var myWebGL = new MyWebGL_1.MyWebGL(glId, 'webgl');\n    _drawPentagon(myWebGL);\n    _drawPentagram(myWebGL);\n}\nexports.drawPentagram = drawPentagram;\n\n\n//# sourceURL=webpack:///./src/pentagram.ts?");

/***/ }),

/***/ "./src/sphere.ts":
/*!***********************!*\
  !*** ./src/sphere.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GlslAttribute_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslAttribute */ \"./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts\");\nvar GlslUniform_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslUniform */ \"./src/MyWebGL/core/glsl/parameter/GlslUniform.ts\");\nvar MyWebGL_1 = __webpack_require__(/*! ./MyWebGL/core/MyWebGL */ \"./src/MyWebGL/core/MyWebGL.ts\");\nvar RenderObject_1 = __webpack_require__(/*! ./MyWebGL/core/RenderObject */ \"./src/MyWebGL/core/RenderObject.ts\");\nvar Vector_1 = __webpack_require__(/*! ./MyWebGL/MathLib/Vector */ \"./src/MyWebGL/MathLib/Vector.ts\");\nvar ModelView_1 = __webpack_require__(/*! ./MyWebGL/core/transform/ModelView */ \"./src/MyWebGL/core/transform/ModelView.ts\");\nvar Projection_1 = __webpack_require__(/*! ./MyWebGL/core/transform/Projection */ \"./src/MyWebGL/core/transform/Projection.ts\");\nvar Transform_1 = __webpack_require__(/*! ./MyWebGL/core/transform/Transform */ \"./src/MyWebGL/core/transform/Transform.ts\");\nvar vsSouce = \"\\n    attribute vec4 vPosition;\\n    attribute vec3 vNormal;\\n\\n    varying vec3 N, L, E;\\n    \\n    uniform mat4 translate;\\n    uniform mat4 modelViewMatrix;\\n    uniform mat4 projectionMatrix;\\n    uniform vec4 lightPosition;\\n\\n    void main() {\\n        vec3 light;\\n        vec3 pos = (modelViewMatrix * translate * vPosition).xyz;\\n        \\n        if(lightPosition.z == 0.0) {\\n            L = normalize(lightPosition.xyz);\\n        } else {\\n            L = normalize(lightPosition).xyz - pos;\\n        }\\n        \\n        E = -normalize(pos);\\n\\n        vec4 NN = vec4(vNormal, 0);\\n        N = normalize((modelViewMatrix * translate * NN).xyz);\\n        \\n        gl_Position = projectionMatrix * modelViewMatrix * translate * vPosition;\\n    }\\n\";\nvar fsSouce = \"\\n    precision mediump float;\\n\\n    uniform vec4 ambientProduct;\\n    uniform vec4 diffuseProduct;\\n    uniform vec4 specularProduct;\\n    uniform float shininess;\\n    \\n    varying vec3 N, L, E;\\n\\n    void main() {    \\n        vec4 fColor;\\n        \\n        vec3 H = normalize(L + E);\\n        vec4 ambient = ambientProduct;\\n\\n        float Kd = max(dot(L, N), 0.0);\\n        vec4 diffuse = Kd * diffuseProduct;\\n\\n        float Ks = pow(max(dot(N, H), 0.0), shininess);\\n        vec4 specular = Ks * specularProduct;\\n        \\n        if (dot(L, N) < 0.0)\\n            specular = vec4(0.0, 0.0, 0.0, 1.0);\\n\\n        fColor = ambient + diffuse +specular;\\n        fColor.a = 1.0;\\n\\n        gl_FragColor = fColor;\\n    }\\n\";\nvar myWebGL;\nvar positions = [];\nvar normPositions = [];\nvar triangleNum = 0;\nvar modelView = ModelView_1.ModelView.lookAt(new Vector_1.Vector([0, 0, 1]), new Vector_1.Vector([0, 0, 0]), new Vector_1.Vector([0, 1, 0]));\nvar projection = Projection_1.Projection.ortho(-3.0, 3.0, -3.0, 3.0, -10, 10);\nvar lightPosition = new Vector_1.Vector([0.0, 2.0, 0.0, 0.0]);\nfunction triangle(a, b, c) {\n    var t1 = b.substract(a);\n    var t2 = c.substract(a);\n    var norm = t2.cross(t1).normalize();\n    normPositions = normPositions.concat(norm.getValues());\n    normPositions = normPositions.concat(norm.getValues());\n    normPositions = normPositions.concat(norm.getValues());\n    positions = positions.concat(a.getValues());\n    positions = positions.concat(b.getValues());\n    positions = positions.concat(c.getValues());\n    triangleNum += 1;\n}\nfunction divideTriangle(a, b, c, count) {\n    if (count > 0) {\n        var ab = a.mix(b, 0.5).normalize(true);\n        var ac = a.mix(c, 0.5).normalize(true);\n        var bc = b.mix(c, 0.5).normalize(true);\n        divideTriangle(a, ab, ac, count - 1);\n        divideTriangle(ab, b, bc, count - 1);\n        divideTriangle(bc, c, ac, count - 1);\n        divideTriangle(ab, bc, ac, count - 1);\n    }\n    else {\n        triangle(a, b, c);\n    }\n}\nfunction tetrahedron(a, b, c, d, n) {\n    divideTriangle(a, b, c, n);\n    divideTriangle(d, c, b, n);\n    divideTriangle(a, d, b, n);\n    divideTriangle(a, c, d, n);\n}\nfunction getPositions() {\n    var va = new Vector_1.Vector([0.0, 0.0, -1.0, 1]);\n    var vb = new Vector_1.Vector([0.0, 0.942809, 0.333333, 1]);\n    var vc = new Vector_1.Vector([-0.816497, -0.471405, 0.333333, 1]);\n    var vd = new Vector_1.Vector([0.816497, -0.471405, 0.333333, 1]);\n    tetrahedron(va, vb, vc, vd, 5);\n}\nfunction getAttributes() {\n    var attributes = new Map();\n    attributes.set('vPosition', new GlslAttribute_1.GlslAttribute('vPosition', 4, positions));\n    attributes.set('vNormal', new GlslAttribute_1.GlslAttribute('vNormal', 3, normPositions));\n    return attributes;\n}\nfunction getUniforms() {\n    var uniforms = new Map();\n    uniforms.set('modelViewMatrix', new GlslUniform_1.GlslUniform('modelViewMatrix', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('projectionMatrix', new GlslUniform_1.GlslUniform('projectionMatrix', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('lightPosition', new GlslUniform_1.GlslUniform('lightPosition', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('ambientProduct', new GlslUniform_1.GlslUniform('ambientProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('diffuseProduct', new GlslUniform_1.GlslUniform('diffuseProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('specularProduct', new GlslUniform_1.GlslUniform('specularProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('shininess', new GlslUniform_1.GlslUniform('shininess', GlslUniform_1.GlslUniformType.float));\n    uniforms.set('translate', new GlslUniform_1.GlslUniform('translate', GlslUniform_1.GlslUniformType.mat4));\n    return uniforms;\n}\nfunction _drawSphere() {\n    getPositions();\n    var attributes = getAttributes();\n    var uniforms = getUniforms();\n    var renderObj = new RenderObject_1.RenderObject(vsSouce, fsSouce, myWebGL.constant.TRIANGLES, triangleNum * 3, attributes, uniforms);\n    var lightAmbient = new Vector_1.Vector([0.2, 0.2, 0.2, 1.0]);\n    var lightDiffuse = new Vector_1.Vector([1.0, 1.0, 1.0, 1.0]);\n    var lightSpecular = new Vector_1.Vector([1.0, 1.0, 1.0, 1.0]);\n    var materialAmbient = new Vector_1.Vector([1.0, 0.0, 1.0, 1.0]);\n    var materialDiffuse = new Vector_1.Vector([1.0, 0.8, 0.0, 1.0]);\n    var materialSpecular = new Vector_1.Vector([1.0, 1.0, 1.0, 1.0]);\n    var materialShininess = 20.0;\n    var ambientProduct = lightAmbient.mult(materialAmbient);\n    var diffuseProduct = lightDiffuse.mult(materialDiffuse);\n    var specularProduct = lightSpecular.mult(materialSpecular);\n    renderObj.updateUniform('ambientProduct', ambientProduct.flatten());\n    renderObj.updateUniform('diffuseProduct', diffuseProduct.flatten());\n    renderObj.updateUniform('specularProduct', specularProduct.flatten());\n    renderObj.updateUniform('lightPosition', lightPosition.flatten());\n    renderObj.updateUniform('shininess', materialShininess);\n    renderObj.updateUniform('modelViewMatrix', modelView.flatten());\n    renderObj.updateUniform('projectionMatrix', projection.flatten());\n    var translate = Transform_1.Transform.translate(1, 0, 0);\n    renderObj.updateUniform('translate', translate.flatten());\n    myWebGL.render(renderObj);\n}\nfunction drawSphere(glId) {\n    myWebGL = new MyWebGL_1.MyWebGL(glId, 'wengl');\n    myWebGL.enable(myWebGL.constant.DEPTH_TEST);\n    _drawSphere();\n}\nexports.drawSphere = drawSphere;\n\n\n//# sourceURL=webpack:///./src/sphere.ts?");

/***/ }),

/***/ "./src/three_objects.ts":
/*!******************************!*\
  !*** ./src/three_objects.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MyWebGL_1 = __webpack_require__(/*! ./MyWebGL/core/MyWebGL */ \"./src/MyWebGL/core/MyWebGL.ts\");\nvar GlslAttribute_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslAttribute */ \"./src/MyWebGL/core/glsl/parameter/GlslAttribute.ts\");\nvar GlslUniform_1 = __webpack_require__(/*! ./MyWebGL/core/glsl/parameter/GlslUniform */ \"./src/MyWebGL/core/glsl/parameter/GlslUniform.ts\");\nvar Projection_1 = __webpack_require__(/*! ./MyWebGL/core/transform/Projection */ \"./src/MyWebGL/core/transform/Projection.ts\");\nvar Transform_1 = __webpack_require__(/*! ./MyWebGL/core/transform/Transform */ \"./src/MyWebGL/core/transform/Transform.ts\");\nvar RenderObject_1 = __webpack_require__(/*! ./MyWebGL/core/RenderObject */ \"./src/MyWebGL/core/RenderObject.ts\");\nvar MathLib_1 = __webpack_require__(/*! ./MyWebGL/MathLib/MathLib */ \"./src/MyWebGL/MathLib/MathLib.ts\");\nvar ModelView_1 = __webpack_require__(/*! ./MyWebGL/core/transform/ModelView */ \"./src/MyWebGL/core/transform/ModelView.ts\");\nvar Vector_1 = __webpack_require__(/*! ./MyWebGL/MathLib/Vector */ \"./src/MyWebGL/MathLib/Vector.ts\");\nvar vsSourcePentagram = \"\\n    attribute vec4 vPosition;\\n\\n    uniform mat4 perspective;\\n    uniform mat4 translate;\\n    uniform mat4 modelView;\\n    uniform mat4 ortho;\\n\\n    void main() {\\n        gl_Position = ortho * perspective * translate * modelView * vPosition;\\n    }\\n\";\nvar vsSourcePentagon = \"\\n    attribute vec4 vPosition;\\n\\n    uniform mat4 perspective;\\n    uniform mat4 translate;\\n    uniform mat4 modelView;\\n    uniform mat4 ortho;\\n\\n    void main() {\\n        gl_Position = ortho * perspective * translate * modelView * vPosition;\\n    }\\n\";\nvar fsSourcePentagram = \"\\n    precision mediump float;\\n\\n    void main() {\\n        gl_FragColor = vec4(0, 0, 0, 1);\\n    }\\n\";\nvar fsSourcePentagon = \"\\n    precision mediump float;\\n\\n    void main() {\\n        gl_FragColor = vec4(1, 1, 0,1);\\n    }\\n\";\nvar vsSourceCube = \"\\n    attribute vec4 vPosition;\\n    attribute vec3 vNormal;\\n\\n    varying vec3 L, N, E;\\n\\n    uniform mat4 translate;\\n    uniform mat4 perspective;\\n    uniform mat4 modelView;\\n    uniform mat4 ortho;\\n    uniform vec4 lightPosition;\\n\\n    void main() {\\n        vec3 light;\\n        vec3 pos = (modelView * translate * vPosition).xyz;\\n\\n        if (lightPosition.z == 0.0) {\\n            L = normalize(lightPosition.xyz);\\n        } else {\\n            L = normalize(lightPosition).xyz - pos;\\n        }\\n\\n        E = -normalize(pos);\\n        \\n        vec4 NN = vec4(vNormal, 0);\\n        N = normalize((modelView * translate * NN).xyz);\\n\\n        gl_Position = ortho * perspective * modelView * translate * vPosition;\\n    }\\n\";\nvar fsSourceCube = \"\\n    precision mediump float;\\n\\n    varying vec3 N, L, E;\\n\\n    uniform vec4 ambientProduct;\\n    uniform vec4 diffuseProduct;\\n    uniform vec4 specularProduct;\\n    uniform float shininess;\\n\\n    void main() {\\n        vec4 fColor;\\n\\n        vec3 H = normalize(L + E);\\n\\n        vec4 ambient = ambientProduct;\\n\\n        float Kd = max(dot(L, N), 0.0);\\n        vec4 diffuse = Kd * diffuseProduct;\\n\\n        float Ks = pow(max(dot(N, H), 0.0), shininess);\\n        vec4 specular = Ks * specularProduct;\\n\\n        if (dot(L, N) < 0.0)\\n            specular = vec4(0.0, 0.0, 0.0, 1.0);\\n\\n        fColor = ambient + diffuse + specular;\\n        fColor.a = 1.0;\\n\\n        gl_FragColor = fColor;\\n    }\\n\";\nvar vsSouceSphere = \"\\n    attribute vec4 vPosition;\\n    attribute vec3 vNormal;\\n    \\n    varying vec3 N, L, E;\\n    \\n    uniform mat4 modelView;\\n    uniform mat4 perspective;\\n    uniform vec4 lightPosition;\\n    uniform mat4 translate;\\n    uniform mat4 ortho;\\n\\n    void main() {\\n        vec3 light;\\n        vec3 pos = (modelView * translate * vPosition).xyz;\\n        \\n        if(lightPosition.z == 0.0) {\\n            L = normalize(lightPosition.xyz);\\n        } else {\\n            L = normalize(lightPosition).xyz - pos;\\n        }\\n        \\n        E = -normalize(pos);\\n\\n        vec4 NN = vec4(vNormal, 0.0);\\n        N = normalize((modelView * translate * NN).xyz);\\n        \\n        gl_Position = ortho * perspective * modelView * translate * vPosition;\\n    }\\n\";\nvar fsSouceSphere = \"\\n    precision mediump float;\\n\\n    uniform vec4 ambientProduct;\\n    uniform vec4 diffuseProduct;\\n    uniform vec4 specularProduct;\\n    uniform float shininess;\\n    \\n    varying vec3 N, L, E;\\n\\n    void main() {    \\n        vec4 fColor;\\n        \\n        vec3 H = normalize(L + E);\\n        vec4 ambient = ambientProduct;\\n\\n        float Kd = max(dot(L, N), 0.0);\\n        vec4 diffuse = Kd * diffuseProduct;\\n\\n        float Ks = pow(max(dot(N, H), 0.0), shininess);\\n        vec4 specular = Ks * specularProduct;\\n        \\n        if(dot(L, N) < 0.0)\\n            specular = vec4(0.0, 0.0, 0.0, 1.0);\\n\\n        fColor = ambient + diffuse +specular;\\n        fColor.a = 1.0;\\n\\n        gl_FragColor = fColor;\\n    }\\n\";\n// pentagram\nvar RADIUS = 1;\n// cube\nvar cubePositions = [];\nvar cubeNormals = [];\n// sphere\nvar spherePositions = [];\nvar sphereNormals = [];\nvar triangleNum = 0;\n// webgl\nvar myWebGL;\n// projection\nvar modelView = ModelView_1.ModelView.lookAt(new Vector_1.Vector([0, 0, 2]), new Vector_1.Vector([0, 0, 0]), new Vector_1.Vector([0, 1, 0]));\nvar perspective;\nvar ortho = Projection_1.Projection.ortho(-3.0, 3.0, -3.0, 3.0, -5.0, 5.0);\n// light\nvar lightPosition = new Vector_1.Vector([0.0, 4.0, 0.0, 0.0]);\nvar lightAmbient = new Vector_1.Vector([0.2, 0.2, 0.2, 1.0]);\nvar lightDiffuse = new Vector_1.Vector([1.0, 1.0, 1.0, 1.0]);\nvar lightSpecular = new Vector_1.Vector([1.0, 1.0, 1.0, 1.0]);\nvar materialAmbient = new Vector_1.Vector([1.0, 0.0, 1.0, 1.0]);\nvar materialDiffuse = new Vector_1.Vector([1.0, 0.8, 0.0, 1.0]);\nvar materialSpecular = new Vector_1.Vector([1.0, 1.0, 1.0, 1.0]);\nvar materialShininess = 20.0;\nvar ambientProduct = lightAmbient.mult(materialAmbient);\nvar diffuseProduct = lightDiffuse.mult(materialDiffuse);\nvar specularProduct = lightSpecular.mult(materialSpecular);\nfunction getPloygonPositions(num, radius, startDegree, stepDegree) {\n    var positions = [];\n    for (var i = 0; i < num; i++) {\n        var degree = startDegree + i * stepDegree;\n        var x = radius * Math.cos(MathLib_1.MathLib.degreeToRadians(degree));\n        var y = radius * Math.sin(MathLib_1.MathLib.degreeToRadians(degree));\n        positions.push([x, y]);\n    }\n    return positions;\n}\nfunction getPentagramPositions() {\n    var stepDegree = 360 / 5;\n    var startDegree = stepDegree / 2;\n    var pointsPositions = getPloygonPositions(5, RADIUS, startDegree, stepDegree);\n    var positions = [];\n    for (var i = 0; i < 3; i++) {\n        positions.push(pointsPositions[i][0], pointsPositions[i][1]);\n        positions.push(pointsPositions[i + 2][0], pointsPositions[i + 2][1]);\n        if (i != 2) {\n            positions.push(pointsPositions[i][0], pointsPositions[i][1]);\n            positions.push(pointsPositions[i + 3][0], pointsPositions[i + 3][1]);\n        }\n    }\n    return positions;\n}\nfunction getPentagonPositions() {\n    var startDegree = 0;\n    var stepDegree = 360 / 5;\n    var pointsPositions = getPloygonPositions(5, MathLib_1.MathLib.sineTheorem(RADIUS, 126, 18), startDegree, stepDegree);\n    var positions = [];\n    for (var i = 0; i < 5; i++) {\n        positions.push(pointsPositions[i][0], pointsPositions[i][1]);\n        positions.push(pointsPositions[(i + 1) % 5][0], pointsPositions[(i + 1) % 5][1]);\n        positions.push(0, 0);\n    }\n    return positions;\n}\nfunction getPentagramAttributes() {\n    var positions = getPentagramPositions();\n    var attributes = new Map();\n    attributes.set('vPosition', new GlslAttribute_1.GlslAttribute('vPosition', 2, positions));\n    return attributes;\n}\nfunction getPentagonAttributes() {\n    var positions = getPentagonPositions();\n    var attributes = new Map();\n    attributes.set('vPosition', new GlslAttribute_1.GlslAttribute('vPosition', 2, positions));\n    return attributes;\n}\nfunction getPentagramUniforms() {\n    var uniforms = new Map();\n    uniforms.set('translate', new GlslUniform_1.GlslUniform('translate', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('perspective', new GlslUniform_1.GlslUniform('perspective', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('modelView', new GlslUniform_1.GlslUniform('modelView', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('ortho', new GlslUniform_1.GlslUniform('ortho', GlslUniform_1.GlslUniformType.mat4));\n    return uniforms;\n}\nfunction getPentagonUniforms() {\n    var uniforms = new Map();\n    uniforms.set('translate', new GlslUniform_1.GlslUniform('translate', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('perspective', new GlslUniform_1.GlslUniform('perspective', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('modelView', new GlslUniform_1.GlslUniform('modelView', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('ortho', new GlslUniform_1.GlslUniform('ortho', GlslUniform_1.GlslUniformType.mat4));\n    return uniforms;\n}\nfunction drawPentagram() {\n    var attributes = getPentagramAttributes();\n    var uniforms = getPentagramUniforms();\n    var rendeObj = new RenderObject_1.RenderObject(vsSourcePentagram, fsSourcePentagram, myWebGL.constant.LINES, 10, attributes, uniforms);\n    var translate = Transform_1.Transform.translate(0, 0, 0);\n    rendeObj.updateUniform('translate', translate.flatten());\n    rendeObj.updateUniform('perspective', perspective.flatten());\n    rendeObj.updateUniform('modelView', modelView.flatten());\n    rendeObj.updateUniform('ortho', ortho.flatten());\n    myWebGL.render(rendeObj);\n}\nfunction drawPentagon() {\n    var attributes = getPentagonAttributes();\n    var uniforms = getPentagonUniforms();\n    var rendeObj = new RenderObject_1.RenderObject(vsSourcePentagon, fsSourcePentagon, myWebGL.constant.TRIANGLES, 15, attributes, uniforms);\n    var translate = Transform_1.Transform.translate(0, 0, 0);\n    rendeObj.updateUniform('translate', translate.flatten());\n    rendeObj.updateUniform('perspective', perspective.flatten());\n    rendeObj.updateUniform('modelView', modelView.flatten());\n    rendeObj.updateUniform('ortho', ortho.flatten());\n    myWebGL.render(rendeObj);\n}\nfunction getCubePositions() {\n    function getPositions(a, b, c, d) {\n        var vertexs = [\n            [-0.5, -0.5, 0.5],\n            [-0.5, 0.5, 0.5],\n            [0.5, 0.5, 0.5],\n            [0.5, -0.5, 0.5],\n            [-0.5, -0.5, -0.5],\n            [-0.5, 0.5, -0.5],\n            [0.5, 0.5, -0.5],\n            [0.5, -0.5, -0.5],\n        ];\n        var av = new Vector_1.Vector(vertexs[a]);\n        var bv = new Vector_1.Vector(vertexs[b]);\n        var cv = new Vector_1.Vector(vertexs[c]);\n        var t1 = bv.substract(av);\n        var t2 = cv.substract(bv);\n        var normal = t1.cross(t2);\n        cubePositions = cubePositions.concat(vertexs[a]);\n        cubeNormals = cubeNormals.concat(normal.getValues());\n        cubePositions = cubePositions.concat(vertexs[b]);\n        cubeNormals = cubeNormals.concat(normal.getValues());\n        cubePositions = cubePositions.concat(vertexs[c]);\n        cubeNormals = cubeNormals.concat(normal.getValues());\n        cubePositions = cubePositions.concat(vertexs[a]);\n        cubeNormals = cubeNormals.concat(normal.getValues());\n        cubePositions = cubePositions.concat(vertexs[c]);\n        cubeNormals = cubeNormals.concat(normal.getValues());\n        cubePositions = cubePositions.concat(vertexs[d]);\n        cubeNormals = cubeNormals.concat(normal.getValues());\n    }\n    getPositions(1, 0, 3, 2);\n    getPositions(2, 3, 7, 6);\n    getPositions(3, 0, 4, 7);\n    getPositions(6, 5, 1, 2);\n    getPositions(4, 5, 6, 7);\n    getPositions(5, 4, 0, 1);\n}\nfunction getCubeAttributes() {\n    getCubePositions();\n    var attributes = new Map();\n    attributes.set('vPosition', new GlslAttribute_1.GlslAttribute('vPosition', 3, cubePositions));\n    attributes.set('vNormal', new GlslAttribute_1.GlslAttribute('vNormal', 3, cubeNormals));\n    return attributes;\n}\nfunction getCubeUniforms() {\n    var uniforms = new Map();\n    uniforms.set('modelView', new GlslUniform_1.GlslUniform('modelView', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('translate', new GlslUniform_1.GlslUniform('translate', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('perspective', new GlslUniform_1.GlslUniform('perspective', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('ortho', new GlslUniform_1.GlslUniform('ortho', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('lightPosition', new GlslUniform_1.GlslUniform('lightPosition', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('ambientProduct', new GlslUniform_1.GlslUniform('ambientProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('diffuseProduct', new GlslUniform_1.GlslUniform('diffuseProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('specularProduct', new GlslUniform_1.GlslUniform('specularProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('shininess', new GlslUniform_1.GlslUniform('shininess', GlslUniform_1.GlslUniformType.float));\n    return uniforms;\n}\nfunction drawCube() {\n    myWebGL.enable(myWebGL.constant.DELETE_STATUS);\n    var attributes = getCubeAttributes();\n    var uniforms = getCubeUniforms();\n    var renderObject = new RenderObject_1.RenderObject(vsSourceCube, fsSourceCube, myWebGL.constant.TRIANGLES, 36, attributes, uniforms);\n    var translate = Transform_1.Transform.translate(4, 0, 0);\n    renderObject.updateUniform('translate', translate.flatten());\n    renderObject.updateUniform('modelView', modelView.flatten());\n    renderObject.updateUniform('perspective', perspective.flatten());\n    renderObject.updateUniform('ortho', ortho.flatten());\n    renderObject.updateUniform('lightPosition', lightPosition.flatten());\n    renderObject.updateUniform('ambientProduct', ambientProduct.flatten());\n    renderObject.updateUniform('diffuseProduct', diffuseProduct.flatten());\n    renderObject.updateUniform('specularProduct', specularProduct.flatten());\n    renderObject.updateUniform('shininess', materialShininess);\n    myWebGL.render(renderObject);\n}\nfunction triangle(a, b, c) {\n    var t1 = b.substract(a);\n    var t2 = c.substract(a);\n    var norm = t2.cross(t1).normalize();\n    sphereNormals = sphereNormals.concat(norm.getValues());\n    sphereNormals = sphereNormals.concat(norm.getValues());\n    sphereNormals = sphereNormals.concat(norm.getValues());\n    spherePositions = spherePositions.concat(a.getValues());\n    spherePositions = spherePositions.concat(b.getValues());\n    spherePositions = spherePositions.concat(c.getValues());\n    triangleNum += 1;\n}\nfunction divideTriangle(a, b, c, count) {\n    if (count > 0) {\n        var ab = a.mix(b, 0.5).normalize(true);\n        var ac = a.mix(c, 0.5).normalize(true);\n        var bc = b.mix(c, 0.5).normalize(true);\n        divideTriangle(a, ab, ac, count - 1);\n        divideTriangle(ab, b, bc, count - 1);\n        divideTriangle(bc, c, ac, count - 1);\n        divideTriangle(ab, bc, ac, count - 1);\n    }\n    else {\n        triangle(a, b, c);\n    }\n}\nfunction tetrahedron(a, b, c, d, n) {\n    divideTriangle(a, b, c, n);\n    divideTriangle(d, c, b, n);\n    divideTriangle(a, d, b, n);\n    divideTriangle(a, c, d, n);\n}\nfunction getSpherePositions() {\n    var va = new Vector_1.Vector([0.0, 0.0, -1.0, 1]);\n    var vb = new Vector_1.Vector([0.0, 0.942809, 0.333333, 1]);\n    var vc = new Vector_1.Vector([-0.816497, -0.471405, 0.333333, 1]);\n    var vd = new Vector_1.Vector([0.816497, -0.471405, 0.333333, 1]);\n    tetrahedron(va, vb, vc, vd, 5);\n}\nfunction getSphereAttributes() {\n    getSpherePositions();\n    var attributes = new Map();\n    attributes.set('vPosition', new GlslAttribute_1.GlslAttribute('vPosition', 4, spherePositions));\n    attributes.set('vNormal', new GlslAttribute_1.GlslAttribute('vNormal', 3, sphereNormals));\n    return attributes;\n}\nfunction getSphereUniforms() {\n    var uniforms = new Map();\n    uniforms.set('modelView', new GlslUniform_1.GlslUniform('modelView', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('perspective', new GlslUniform_1.GlslUniform('perspective', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('translate', new GlslUniform_1.GlslUniform('translate', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('ortho', new GlslUniform_1.GlslUniform('ortho', GlslUniform_1.GlslUniformType.mat4));\n    uniforms.set('lightPosition', new GlslUniform_1.GlslUniform('lightPosition', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('ambientProduct', new GlslUniform_1.GlslUniform('ambientProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('diffuseProduct', new GlslUniform_1.GlslUniform('diffuseProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('specularProduct', new GlslUniform_1.GlslUniform('specularProduct', GlslUniform_1.GlslUniformType.vec4));\n    uniforms.set('shininess', new GlslUniform_1.GlslUniform('shininess', GlslUniform_1.GlslUniformType.float));\n    return uniforms;\n}\nfunction drawSphere() {\n    var attributes = getSphereAttributes();\n    var uniforms = getSphereUniforms();\n    var renderObj = new RenderObject_1.RenderObject(vsSouceSphere, fsSouceSphere, myWebGL.constant.TRIANGLES, triangleNum * 3, attributes, uniforms);\n    var translate = Transform_1.Transform.translate(-3.5, 0, 0);\n    renderObj.updateUniform('ambientProduct', ambientProduct.flatten());\n    renderObj.updateUniform('diffuseProduct', diffuseProduct.flatten());\n    renderObj.updateUniform('specularProduct', specularProduct.flatten());\n    renderObj.updateUniform('lightPosition', lightPosition.flatten());\n    renderObj.updateUniform('shininess', materialShininess);\n    renderObj.updateUniform('modelView', modelView.flatten());\n    renderObj.updateUniform('perspective', perspective.flatten());\n    renderObj.updateUniform('ortho', ortho.flatten());\n    renderObj.updateUniform('translate', translate.flatten());\n    myWebGL.render(renderObj);\n}\nfunction drawThreeObjects(glId) {\n    myWebGL = new MyWebGL_1.MyWebGL(glId, 'webgl');\n    myWebGL.enable(myWebGL.constant.DEPTH_TEST);\n    perspective = Projection_1.Projection.perspective(90, myWebGL.canvas.width / myWebGL.canvas.height, 0.3, 10);\n    drawPentagon();\n    drawPentagram();\n    drawCube();\n    drawSphere();\n}\nexports.drawThreeObjects = drawThreeObjects;\n\n\n//# sourceURL=webpack:///./src/three_objects.ts?");

/***/ })

/******/ });